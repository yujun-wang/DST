{
  "name": "async-chainable",
  "version": "1.7.1",
  "description": "An extension to Async adding better handling of mixed Series / Parallel tasks via object chaining",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/hash-bang/async-chainable"
  },
  "license": "MIT",
  "keywords": [
    "async",
    "chain",
    "chainable",
    "parallel",
    "series",
    "tasks",
    "seq"
  ],
  "author": {
    "name": "Matt Carter",
    "email": "m@ttcarter.com"
  },
  "bugs": {
    "url": "https://github.com/hash-bang/async-chainable/issues"
  },
  "homepage": "https://github.com/hash-bang/async-chainable",
  "scripts": {
    "coverage": "istanbul cover node_modules/.bin/_mocha",
    "test": "mocha test"
  },
  "devDependencies": {
    "chai": "^1.10.0",
    "istanbul": "^0.3.5",
    "mocha": "^2.1.0",
    "mocha-istanbul": "^0.2.0"
  },
  "dependencies": {
    "async": "~0.9.0"
  },
  "readme": "async-chainable\n===============\nAn extension to the otherwise excellent [Async](https://www.npmjs.com/package/async) library adding better handling of mixed Series / Parallel tasks via object chaining.\n\n\n\tvar asyncChainable = require('async-chainable');\n\n\tasyncChainable() // <- Note '()' as this module is not stateless\n\t\t.parallel([fooFunc, barFunc, bazFunc]) // Do these operations in parallel THEN\n\t\t.series([fooFunc, barFunc, bazFunc]) // Do these in series (NOTE: these only run when the above has resolved)\n\t\t.end(console.log)\n\n\n\tasyncChainable()\n\t\t.limit(2) // Allow only 2 defer items to run at once from this point on\n\t\t.defer('foo', fooFunc) // Run this now and continue on...\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we don't care about 'baz' yet\n\t\t.then(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\t\t.await() // Wait for everything else\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\n\tasyncChainable()\n\t\t.parallel('foo', fooFunc)\n\t\t.prereq('foo', 'bar', barFunc) // Only let this function run when 'foo' has completed\n\t\t.prereq(['foo', 'bar'], 'baz', bazFunc) // Only let this function run when both 'foo' and 'bar' have completed\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\n\tasyncChainable()\n\t\t.forEach([\n\t\t\t'What do we want?',\n\t\t\t'Race conditions!',\n\t\t\t'When do we want them?',\n\t\t\t'Whenever!',\n\t\t], function(next, item) {\n\t\t\t// Prints the above array items to the console in parallel (i.e. whichever resolve first - no gurenteeed order)\n\t\t\tconsole.log(item);\n\t\t\tnext();\n\t\t})\n\t\t.end();\n\n\n\n\t// Or use contexts (i.e. `this`) - see Contexts section for more information\n\tasyncChainable()\n\t\t.parallel({\n\t\t\tfoo: fooFunc,\n\t\t\tbar: barFunc,\n\t\t\tbaz: bazFunc\n\t\t})\n\t\t.then(function(next) {\n\t\t\tconsole.log(this); // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value', /* META INFO */}\n\t\t\tconsole.log('Foo =', this.foo); // Output: 'Foo = ', 'foo value'\n\t\t\tnext();\n\t\t})\n\t\t.end();\n\n\n\t// Call in stages without chaining\n\tvar tasks = asyncChainable();\n\n\ttasks.defer('foo', fooFunc);\n\n\ttasks.defer('bar', barFunc);\n\n\tif (/* some internal logic */) {\n\t\ttasks.defer('bar', 'baz', bazFunc); // Only start 'baz' when 'bar' has completed\n\t}\n\n\ttasks.end(); // Kick everything off\n\n\n\n\t// Specify prerequisites and let async-chainable figure everything out automatically\n\t// This style replaces async.auto() which is a bit ugly\n\n\tasyncChainable()\n\n\t\t// Task 'foo' relies on 'quz'\n\t\t.defer('quz', 'foo', function(next) { next(null, 'fooValue') })\n\n\t\t// Task 'bar' relies on 'baz' and 'foo'\n\t\t.defer(['baz', 'foo'], 'bar', function(next) { next(null, 'barValue') })\n\n\t\t// Task 'bar' doesnt need any pre-requisites\n\t\t.defer('baz', function(next) { next(null, 'bazValue') })\n\n\t\t// Task 'quz' relies on 'baz'\n\t\t.defer('baz', 'quz', function(next) { next(null, 'quzValue') })\n\t\t\n\t\t// Wait for everything to finish\n\t\t.await()\n\t\t.end();\n\n\nThis module extends the existing async object so you can use it as a drop in replacement for Async:\n\n\tvar async = require('async-chainable');\n\n\tasync().waterfall([fooFunc, barFunc, bazFunc], console.log); // Async goodness\n\n\t// With new async-chainable flexibility\n\tasync() // <- Note unfortunately you still have to add '()' to the main invoker\n\t\t.parallel([fooFunc, barFunc, bazFunc]) // Do these operations in parallel THEN\n\t\t.series([fooFunc, barFunc, bazFunc]) // Do these in series (note these only run when the above has resolved)\n\t\t.end(console.log)\n\n\t// Or just like async\n\t// NOTE: This style cannot be chained in order to maintain compability with async\n\tasync.parallel([fooFunc, barFunc, bazFunc], console.log);\n\n\nFAQ\n===\nSome frequently asked questions:\n\n* **Why not just use Async?** - Async is an excellent library and suitable for 90% of tasks out there but it quickly becomes unmanageable when dealing with complex nests such as a mix of series and parallel tasks.\n\n* **Why was this developed?** - Some research I was doing involved the nesting of ridiculously complex parallel and series based tasks and Async was becoming more of a hindrance than a helper.\n\n* **What alternatives are there to this library?** - The only ones I've found that come close are [node-seq](https://github.com/substack/node-seq) and [queue-async](https://www.npmjs.com/package/queue-async) but both of them do not provide the functionality listed here\n\n* **Is this the module I should use for Async JavaScript?** - If you're doing simple parallel or series based tasks use [Async](https://www.npmjs.com/package/async), if you're doing complex nested operations you might want to take a look at this one\n\n* **Whats license do you use?** - We use the [MIT license](LICENSE), please credit the original library and authors if you wish to fork or share\n\n* **Who wrote this / who do I blame?** - [Matt Carter](https://github.com/hash-bang) and [David Porter](https://github.com/DesertLynx)\n\n\nMore complex examples\n=====================\n\n\tvar asyncChainable = require('async-chainable');\n\n\t// Simple nesting of series and parallel operations\n\tasyncChainable()\n\t\t// The following 3 functions execute in series\n\t\t.series([\n\t\t\tfunction(next) { setTimeout(function() { console.log('Series 1'); next(); }, 100); },\n\t\t\tfunction(next) { setTimeout(function() { console.log('Series 2'); next(); }, 200); },\n\t\t\tfunction(next) { setTimeout(function() { console.log('Series 3'); next(); }, 300); },\n\t\t])\n\n\t\t// ...then we run this...\n\t\t.then(function(next) {\n\t\t\tconsole.log('Finished step 1');\n\t\t})\n\n\t\t// ...then the next three run in parallel\n\t\t.parallel([\n\t\t\tfunction(next) { setTimeout(function() { console.log('Parallel 1'); next(); }, 300); },\n\t\t\tfunction(next) { setTimeout(function() { console.log('Parallel 2'); next(); }, 200); },\n\t\t\tfunction(next) { setTimeout(function() { console.log('Parallel 3'); next(); }, 100); },\n\t\t])\n\t\t.end(function(next) {\n\t\t\tconsole.log('Finished simple example');\n\t\t});\n\n\t\n\t// Parameters can be passed by using named functions\n\n\tasyncChainable()\n\t\t.series({ // Since this is node we can KINDA rely on it storing the hash in the right order, don't splice or alter the hash past declaring it though or this functionality will break. Alternatively use the below syntax\n\t\t\tfoo: function(next) {\n\t\t\t\tsetTimeout(function() { console.log('Series 2-1'); next(null, 'foo result'); }, 100);\n\t\t\t},\n\t\t\tbar: function(next, results) {\n\t\t\t\t// We can access results from any function\n\t\t\t\tsetTimeout(function() { console.log('Series 2-2'); next(null, 'bar result'); }, 100);\n\t\t\t},\n\t\t\tbaz: function(next) {\n\t\t\t\tsetTimeout(function() { console.log('Series 2-3'); next(null, 'baz result'); }, 100);\n\t\t\t},\n\t\t})\n\t\t.parallel({ // See above comment about Node storing hashes in the right accessible order\n\t\t\tfooParallel: function(next) {\n\t\t\t\tsetTimeout(function() { console.log('Series 2-1'); next(null, 'foo parallel result'); }, 100);\n\t\t\t},\n\t\t\tbarParallel: function(next) {\n\t\t\t\tsetTimeout(function() { console.log('Series 2-2'); next(null, 'bar parallel result'); }, 100);\n\t\t\t},\n\t\t\tbazParallel: function(next) {\n\t\t\t\tsetTimeout(function() { console.log('Series 2-3'); next(null, 'baz parallel result'); }, 100);\n\t\t\t},\n\t\t})\n\t\t.then(function(next, results) {\n\t\t\t// We also get all the results at the end\n\t\t\tconsole.log(\"Results\", results); // results = {foo: 'foo result', bar: 'bar result'... 'fooParallel': 'foo parallel result'...}\n\t\t})\n\t\t.reset() // Or we can clear out the results manually\n\t\t.end(function(next, results) {\n\t\t\tconsole.log('Results should be blank', results);\n\t\t};\n\n\n\t// In the below examples we assume fooFunc, barFunc, bazFunc and quzFunc functions look something like this:\n\tfooFunc = barFunc = bazFunc = quzFunc = function(next) {\n\t\tsetTimeout(function() {\n\t\t\tnext(null, arguments.callee.toString().substr(0, 3) + ' value'); // Continue on with 'foo value', 'bar value' etc.\n\t\t}, Math.random() * 1000); // After a random wait of up to a second\n\t};\n\n\t// Alternative syntaxes\n\t// All of the below are syntactically the same and will output null, 'foo', 'bar', 'baz (first value is error)\n\t// In each we assume 'series' is the rule but 'parallel' could be substituted if we don't care about sequence\n\t// In each case we have named the functions (e.g. 'foo') but we could just omit this and have a function if we don't care about the result\n\n\t// Hash style syntax\n\t// NOTE: This relies on the hash not changing order of the keys which is a bit of an issue if you're adding / removing from it out of sequence\n\tasyncChainable()\n\t\t.series({foo: fooFunc, bar: barFunc, baz: bazFunc})\n\t\t.end(console.log);\n\n\t// Named function style syntax - series only\n\tasyncChainable()\n\t\t.then('foo', fooFunc)\n\t\t.then('bar', barFunc)\n\t\t.then('baz', bazFunc)\n\t\t.end(console.log);\n\n\t// Named function style syntax - parallel only\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Start this function immediately and continue on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await() // Resolve all deferred functions before continuing\n\t\t.end(console.log);\n\n\t// Named function style syntax - parallel only\n\t// This works the same as above where if parallel() is NOT passed a hash or array it will act as if called with defer()\n\tasyncChainable()\n\t\t.parallel('foo', fooFunc) // Start this function immediately and continue on\n\t\t.parallel('bar', barFunc)\n\t\t.parallel('baz', bazFunc)\n\t\t.await() // Resolve all deferred functions before continuing\n\t\t.end(console.log);\n\n\tasyncChainable()\n\t\t.limit(2) // Allow only 2 defer operations to run at once\n\t\t.defer('foo', fooFunc)\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we don't care about 'baz' yet\n\t\t.then(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\t\t.await() // Wait for everything else\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\n\n\t// Classic asyncChainable functionality is still available\n\n\tasyncChainable()\n\t\t.waterfall([\n\t\t\tfunction(next) { next(null, 'foo') };\n\t\t\tfunction(next, fooResult) { console.log(fooResult); next(); } // Output = 'foo'\n\t\t]);\n\n\n\n\t// Regular asyncChainable functionality is all there but is now chainable\n\n\tasyncChainable()\n\t\t.each()\n\t\t.eachSeries()\n\t\t.map()\n\t\t.mapSeries()\n\t\t.mapLimit()\n\t\t.filter()\n\t\t.filterSeries()\n\t\t.reject()\n\t\t.rejectSeries()\n\t\t.reduce()\n\t\t.reduceRight()\n\t\t.detect()\n\t\t.detectSeries()\n\t\t.sortBy()\n\t\t.some()\n\t\t.every()\n\t\t.concat()\n\t\t.concatSeries()\n\n\tasyncChainable()\n\t\t.parallelLimit()\n\t\t.whilst()\n\t\t.doWhilst()\n\t\t.until()\n\t\t.doUntil()\n\t\t.forever()\n\t\t.waterfall()\n\t\t.compose()\n\t\t.seq()\n\t\t.applyEach()\n\t\t.applyEachSeries()\n\t\t.queue()\n\t\t.priorityQueue()\n\t\t.cargo()\n\t\t.auto()\n\t\t.retry()\n\t\t.iterator()\n\t\t.apply()\n\t\t.nextTick()\n\t\t.times()\n\t\t.timesSeries()\n\n\tasyncChainable()\n\t\t.memoize()\n\t\t.unmemoize()\n\t\t.log()\n\t\t.dir()\n\t\t.noConflict()\n\n\nAPI\n===\n\n.series() / .parallel()\n-----------------------\nExecute an array or object of functions either in series or parallel.\n\n\tseries(function)\n\tseries(string, function) // Named function (`this.name` gets set to whatever gets passed to `next()`)\n\tseries(array)\n\tseries(object) // Named function object (each object key gets assigned to this with the value passed to `next()`)\n\tseries(collection) // See 'object' definition\n\tseries(array, function) // Backwards compatibility with `async.series`\n\tseries(object, function) // Backwards compatibility with `async.series`\n\n\tparallel(function)\n\tparallel(string, function) // Named function (`this.name` gets set to whatever gets passed to `next()`)\n\tparallel(array)\n\tparallel(object) // Named function object (each object key gets assigned to this with the value passed to `next()`)\n\tparallel(collection) // See 'object' definition\n\tparallel(array, function) // Backwards compatibility with `parallel.series`\n\tparallel(object, function) // Backwards compatibility with `parallel.series`\n\n\nSome examples:\n\n\n\tasyncChainable()\n\t\t.parallel(Array) // Execute all items in the array in parallel\n\t\t.parallel(Object) // Execute all items in the object in parallel storing any return against the object key\n\t\t.parallel(Collection) // i.e. an array of objects - this is to work around JS not maintaining hash key orders\n\t\t.parallel(String, function) // Execute function now and await output, then store in object against key specified by String\n\t\t.parallel(function) // Exactly the same functionality as `defer()`\n\t\t.end()\n\n\n\tasyncChainable()\n\t\t.series(Array) // Execute all items in the array in parallel\n\t\t.series(Object) // Execute all items in the object in series storing any return against the object key\n\t\t.series(Collection) // i.e. an array of objects - this is to work around JS not maintaining hash key orders\n\t\t.series(String, function) // Execute function now and await output, then store in object against key specified by String\n\t\t.series(function) // Exactly the same functionality as `then()`\n\t\t.end()\n\n\n.defer()\n--------\nExecute a function and continue down the asyncChainable chain.\n\n\tdefer(function)\n\tdefer(string, function) // Named function (`this.name` gets set to whatever gets passed to `next()`)\n\tdefer(string, string, function) // Named function (name is second arg) with prereq (first arg)\n\tdefer(array, string, function) // Named function (name is second arg) with prereq array (first arg)\n\tdefer(array)\n\tdefer(object) // Named function object (each object key gets assigned to this with the value passed to `next()`)\n\tdefer(collection) // See 'object' definition\n\tdefer(null) // Gets skipped automatically\n\n\nUse `await()` to gather the parallel functions.\nThis can be considered the parallel process twin to `series()` / `then()`.\n\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we dont care about 'baz' yet\n\t\t.then(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\t\t.await() // Wait for everything else\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n.await()\n--------\nWait for one or more fired defer functions to complete before containing down the asyncChainable chain.\n\n\tawait() // Wait for all defered functions to finish\n\tawait(string) // Wait for at least the named defer to finish\n\tawait(string,...) // Wait for the specified named defers to finish\n\tawait(array) // Wait for the specified named defers to finish\n\n\nSome examples:\n\n\t// Wait for everything\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await() // Wait for all defers to finish\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\n\t// Wait for certain defers\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we dont care about 'baz' yet\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\n\n\t// Wait for certain defers - array syntax\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await(['foo', 'bar']) // Wait for 'foo' and 'bar' parallel functions to finish but we dont care about 'baz' yet\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\n\n.limit()\n--------\nRestrict the number of defer operations that can run at any one time.\n\n\tlimit() // Allow unlimited parallel / defer functions to execute at once after this chain item\n\tlimit(Number) // Restrict the number of parallel / defer functions after this chain item\n\n\nThis function can be used in the pipeline as many times as needed to change the limit as we work down the execution chain.\n\n\tasyncChainable()\n\t\t.limit(2) // Allow only 2 defer operations to run at once from this point onward\n\t\t.defer(fooFunc)\n\t\t.defer(barFunc)\n\t\t.defer(bazFunc)\n\t\t.defer(quzFunc)\n\t\t.await()\n\t\t.limit(3) // Allow 3 defer operations to run at once from this point onward\n\t\t.defer(fooFunc)\n\t\t.defer(barFunc)\n\t\t.defer(bazFunc)\n\t\t.defer(quzFunc)\n\t\t.await()\n\t\t.limit() // Allow unlimited operations to run at once from this point onward (0 / false / null is also permissable as 'unlimited')\n\t\t.defer(fooFunc)\n\t\t.defer(barFunc)\n\t\t.defer(bazFunc)\n\t\t.defer(quzFunc)\n\t\t.await()\n\t\t.end(console.log)\n\n\n.then()\n-------\nExecute a function, wait for it to complete and continue down the asyncChainable chain.\n\nThis function is an alias for `series()`.\n\nThis can be considered the series process twin to `then()`.\n\n\tasyncChainable()\n\t\t.then('foo', fooFunc) // Execute and wait for fooFunc() to complete\n\t\t.then('bar', barFunc) // Likewise barFunc()\n\t\t.then('baz', bazFunc) // Likewise bazFunc()\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\n.forEach()\n----------\nThe `forEach()` function is a slight variation on the `parallel()` function but with some additional behaviour.\n\n\n\tforEach(array, function) // Run each item in the array though `function(next, value)`\n\tforEach(object, function) // Run each item in the object though `function(next, value, key)`\n\tforEach(collection,function) // see 'array, function' definition (collections are just treated like an array of objects with 'forEach')\n\tforEach(string, function) // Lookup `this[string]` then process according to its type (see above type styles) - This is used for late binding\n\tforEach(null) // Gets skipped automatically (also empty arrays, objects)\n\n\nIt can be given an array, object or collection as the first argument and a function as the second. All items in the array will be iterated over *in parallel* and passed to the function which is expected to execute a next condition returning an error if the forEach iteration should stop.\n\n\tasyncChainable()\n\t\t.forEach(['foo', 'bar', 'baz'], function(next, item, key) { console.log(item) }) // Output: foo, bar and baz in whichever they evaluate\n\t\t.end();\n\nIn the above example the simple array is passed to the function with each payload item as a parameter and the iteration key (an offset if its an array or collection, a key if its an object).\n\n`forEach()` has one additional piece of behaviour where if the first argument is a string the context will be examined for a value to iterate over.\n\n\n\tasyncChainable()\n\t\t.set({\n\t\t\titems: ['foo', 'bar', 'baz'],\n\t\t})\n\t\t.forEach('items', function(next, item, key) { console.log(item) }) // Output: foo, bar and baz in whichever they evaluate\n\t\t.end();\n\nThis allows *late binding* of variables who's content will only be examined when the chain item is executed.\n\n\n.end()\n------\nThe final stage in the chain, `.end()` must be called to execute the queue of actions.\n\n\tend(function) // Final function to execute as `function(err)`\n\n\nWhile similar to `series()` / `then()` this function will always be executed *last* and be given the error if any occurred in the form `function(err)`.\n\n\tasyncChainable()\n\t\t.then('foo', fooFunc) // Execute and wait for fooFunc() to complete\n\t\t.then('bar', barFunc) // Likewise barFunc()\n\t\t.then('baz', bazFunc) // Likewise bazFunc()\n\t\t.end(console.log) // Output: null, {foo: 'foo value', bar: 'bar value', baz: 'baz value'}\n\n\nIn the above if fooFunc, barFunc or bazFunc call next with a first parameter that is true execution will stop and continue on passing the error to `end()`:\n\n\tasyncChainable()\n\t\t.then('foo', fooFunc) // Assuming fooFunc calls next('This is an error')\n\t\t.then('bar', barFunc) // Gets skipped as we have an error\n\t\t.then('baz', bazFunc) // Gets skipped as we have an error\n\t\t.end(console.log) // Output: 'This is an error'\n\n\nIf an error is caused in the middle of execution the result object is still available:\n\n\tasyncChainable()\n\t\t.then('foo', fooFunc) // Assuming this calls `next()` with next(null, 'foo value')\n\t\t.then('bar', barFunc) // Assuming this calls next('Error in bar')\n\t\t.then('baz', bazFunc) // Gets skipped as we have an error\n\t\t.end(console.log) // Output: 'Error in bar', {foo: 'foo value'}\n\n\n.new()\n------\nAsync-chainable operates as an instantiated object. In order to get a new instance (e.g. for nesting invocations) call `.new()` to get a fresh object which wont interfere with any currently live versions.\n\nThe below example uses two versions of async-chainable. The default outer item wraps a new instance of the inner one.\n\n\tasyncChainable()\n\t\t.series([\n\t\t\tfooFunc,\n\t\t\tfunction(outerNext) { \n\t\t\t\tasyncChainable.new() // Make new instance of async-chainable so we can nest\n\t\t\t\t\t.series([\n\t\t\t\t\t\tbarFunc,\n\t\t\t\t\t\tbazFunc,\n\t\t\t\t\t\tquzFunc,\n\t\t\t\t\t])\n\t\t\t\t\t.end(function(err) {\n\t\t\t\t\t\touterNext(err);\n\t\t\t\t\t});\n\t\t\t},\n\t\t])\n\t\t.end(function(err) {\n\t\t\tdone();\n\t\t});\n\n\n.reset()\n---------\nClear the result buffer, releasing all results held in memory.\n\n\tasyncChainable()\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we dont care about 'baz' yet\n\t\t.then(console.log) // Output: null, {foo: 'foo value', bar: 'bar value'}\n\t\t.reset()\n\t\t.defer('quz', quzFunc)\n\t\t.end(console.log) // Output: null, {quz: 'quz value'}\n\n\n.context()\n----------\nSet the context used by async-chainable during subsequent function calls.\nIn effect this sets what `this` is for each call.\nOmitting an argument or supplying a 'falsy' value will instruct async-chainable to use its own default context object.\n\n\tasyncChainable()\n\t\t.then({foo: fooFunc}) // `this` is async-chainables own context object\n\t\t.context({hello: 'world'})\n\t\t.then({bar: barFunc}) // `this` is now {hello: 'world'}\n\t\t.context()\n\t\t.then({baz: bazFunc}) // `this` is now async-chainables own context object again\n\t\t.end(this) // Output: null, {foo: 'foo value', bar: 'bar value', quz: 'quz value'}\n\nNote that even if the context is switched async-chainable still stores any named values in its own context for later retrieval (in the above example this is `barFunc()` returning a value even though the context has been changed to a custom object).\n\nSee the [Context Section](#context) for further details on what the async-chainable context object contains.\n\n\n.set()\n------\nSet is a helper function to quickly allocate the value of a context item as we move down the chain.\n\n\tset(string, mixed) // Set the single item in `this` specified the first string to the value of the second arg\n\tset(object) // Merge the object into `this` to quickly set a number of values\n\tset(function) // Alias for `series(function)`\n\tset(string, function) // Alias for `series(string, function)`\n\n\nIt can be used as a named single item key/value or as a setter object.\n\n\tasyncChainable()\n\t\t.set('foo', 'foo value'])\n\t\t.then(function(next) { console.log(this.foo); next() }) // this.foo is now 'foo value'\n\t\t.set({bar: 'bar value']) \n\t\t.then(function(next) { console.log(this.foo); next() }) // this.bar is now 'bar value' (as well as .foo being also set)\n\t\t.set(baz, function(next) { next(null, 'baz value') }) // this.baz is now 'baz value' (this is actually just an alias for .series())\n\t\t.then(function(next) { console.log(this.foo); next() }) // this.baz is now 'baz value' (as well as .foo, .bar being also set)\n\t\t.end()\n\n\n\nContext\n=======\nUnless overridden by a call to `.context()`, async-chainable will use its own context object which can be accessed via `this` inside any callback function.\nThe context contains the results of any *named* functions as well as some meta data.\n\n\n\tasyncChainable()\n\t\t.series('foo', fooFunc)\n\t\t.defer('foo', fooFunc) // Execute fooFunc() and immediately move on\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await('foo', 'bar') // Wait for 'foo' and 'bar' parallel functions to finish but we dont care about 'baz' yet\n\t\t.then(function(next) {\n\t\t\tconsole.log('Context is', this); // Output 'Context is', {foo: 'foo value', bar: 'bar value', /* META FIELDS */}\n\t\t\tnext();\n\t\t})\n\t\t.await('baz')\n\t\t.end(function(next) {\n\t\t\tconsole.log('Context is', this); // Output 'Context is', {foo: 'foo value', bar: 'bar value', baz: 'baz value', /* META FIELDS */}\n\t\t\tnext();\n\t\t});\n\n\nIn addition to storing all named values the context object also provides the following meta object values.\n\n| Key                                  | Type           |  Description                                                             |\n|--------------------------------------|----------------|--------------------------------------------------------------------------|\n| `this._struct`                       | Collection     | The structure of the async chain constructed by the developer            |\n| `this._structPointer`                | Int            | Offset in the `this._struct` collection as to the current executing function. Change this if you wish to move up and down |\n| `this._options`                      | Object         | Various options used by async-chainable including things like the defer limit |\n| `this._deferredRunning`              | Int            | The number of running deferred tasks (limit this using .limit())         |\n| `this._item`                         | Mixed          | During a forEach loop `_item` gets set to the currently iterating item value |\n| `this._key`                          | Mixed          | During a forEach loop `_key` gets set to the currently iterating array offset or object key |\n\n\nEach item in the `this._struct` object is composed of the following keys:\n\n\n| Key                                  | Type           |  Description                                                             |\n|--------------------------------------|----------------|--------------------------------------------------------------------------|\n| `completed`                          | Boolean        | An indicator as to whether this item has been executed yet               |\n| `payload`                            | Mixed          | The options for the item, in parallel or series modes this is an array or object of the tasks to execute |\n| `type`                               | String         | A supported internal execution type                                      |\n| `waitingOn`                          | Int            | When the type is a defer operation this integer tracks the number of defers that have yet to resolve |\n\n\nGotchas\n=======\nA list of some common errors when using async-chainable.\n\n\nForgetting a final `await()` when using `end()`\n-----------------------------------------------\n\nBy default async-chainable will not *imply* an `.await()` call before each `.end()` call. For example:\n\n\tasyncChainable()\n\t\t.defer('foo', fooFunc)\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.end(console.log);\n\nIn the above no `.await()` call is made before `.end()` so this chain will *immediately* complete - async-chainable will **not** wait for the deferred tasks to complete.\n\n\tasyncChainable()\n\t\t.defer('foo', fooFunc)\n\t\t.defer('bar', barFunc)\n\t\t.defer('baz', bazFunc)\n\t\t.await()\n\t\t.end(console.log);\n\nIn the above async-chainable will wait for the deferred tasks to complete before firing the end condition.\n\n\nForgetting the `()` when initializing\n-------------------------------------\n\nAsync-chainable needs to store state as it processes the task stack, to do this it instantiates itself as an object. This means you must declare it with an additional `()` after the `require()` statement if you wish to use it straight away. For example:\n\n\n\tvar asyncChainable = require('async-chainable')(); // NOTE '()'\n\n\tasyncChainable()\n\t\t.parallel([fooFunc, barFunc, bazFunc])\n\t\t.series([fooFunc, barFunc, bazFunc])\n\t\t.end(console.log)\n\n\nIf you want to use multiple instances you can use either:\n\n\n\tvar asyncChainable = require('async-chainable'); // NOTE: this returns the libray not the instance\n\n\tasyncChainable()\n\t\t.parallel([fooFunc, barFunc, bazFunc])\n\t\t.series([fooFunc, barFunc, bazFunc])\n\t\t.end(console.log)\n\n\tasyncChainable()\n\t\t.parallel([fooFunc, barFunc, bazFunc])\n\t\t.series([fooFunc, barFunc, bazFunc])\n\n\t\t.end(console.log)\n\nOr you can use the built in `.new()` variable to get a new instance:\n\n\tvar asyncChainable = require('async-chainable')(); // NOTE: this returns an instance\n\n\tasyncChainable()\n\t\t.parallel([fooFunc, barFunc, bazFunc])\n\t\t.series([fooFunc, barFunc, bazFunc])\n\t\t.end(console.log)\n\n\tasyncChainable().new() // NOTE: 'new' request\n\t\t.parallel([fooFunc, barFunc, bazFunc])\n\t\t.series([fooFunc, barFunc, bazFunc])\n\t\t.end(console.log)\n\n\nIts annoying we have to do this but without hacking around how Nodes module system works its not possible to return a singleton object like the async library does *and also* work with nested instances (i.e. having one .js file require() another that uses async-chainable and the whole thing not end up in a messy stack trace as the second instance inherits the firsts return state).\n\n\nUseful techniques\n=================\n\nMake a variable number of tasks then execute them\n-------------------------------------------------\nSince JavaScript passes everything via pointers you can pass in an array or object to a .parallel() or .series() call which will get evaluated only when that chain item gets executed. This means that preceding items can rewrite the actual tasks conducted during that call.\n\nFor example in the below `otherTasks` is an array which is passed into the .parallel() call (the second chain item). However the initial .then() callback actually writes the items that that parallel call should make.\n\n\tvar otherTasks = [];\n\n\tasyncChainable()\n\t\t.then(function(next) {\n\t\t\tfor (var i = 0; i < 20; i++) {\n\t\t\t\t(function(i) { // Make a closure so 'i' doesnt end up being 20 all the time (since its passed by reference)\n\t\t\t\t\totherTasks.push(function(next) {\n\t\t\t\t\t\tconsole.log('Hello World', i);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t})(i);\n\t\t\t}\n\t\t\tnext();\n\t\t})\n\t\t.parallel(otherTasks)\n\t\t.end();\n\n\nCompose an array of items then run each though a handler function\n-----------------------------------------------------------------\nLike the above example async-chainable can be used to prepare items for execution then thread them into a subsequent chain for processing.\nThis is a neater version of the above that uses a fixed processing function to process an array of data.\n\n\n\tvar asyncChainable = require('./index');\n\n\tvar items = [];\n\n\tasyncChainable()\n\t\t.then(function(next) {\n\t\t\tfor (var i = 0; i < 20; i++) {\n\t\t\t\titems.push({text: 'Hello World ' + i});\n\t\t\t}\n\t\t\tnext();\n\t\t})\n\t\t.forEach(items, function(next, item) {\n\t\t\tconsole.log(item);\n\t\t\tnext();\n\t\t})\n\t\t.end();\n\n\nTODO\n====\n* README: Example of .set() / .then() with something like downloading a stream of data\n* `this.next()` as a possible way to call the next handler?\n",
  "readmeFilename": "README.md",
  "_id": "async-chainable@1.7.1",
  "_from": "async-chainable@~1.7.1"
}
