{
  "name": "mongoose-scenario",
  "version": "0.3.4",
  "description": "Write scenario files which quickly allow you to populate Mongo / Mongoose contents",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/hash-bang/Node-Mongoose-Scenario"
  },
  "keywords": [
    "mongoose",
    "mongo",
    "scenario",
    "population",
    "database",
    "setup"
  ],
  "author": {
    "name": "Matt Carter",
    "email": "m@ttcarter.com"
  },
  "license": "MIT",
  "dependencies": {
    "lodash": "~2.4.1",
    "async": "~0.9.0"
  },
  "devDependencies": {
    "mongoose": "~3.8.20",
    "tape": "~3.0.3",
    "lodash": "~2.4.1"
  },
  "readme": "Mongoose-Scenario\n=================\nWrite scenario files which quickly allow you to populate Mongo / Mongoose model contents.\n\n\nInstallation\n------------\nUse [NPM](https://www.npmjs.org) to install:\n\n\tnpm install --save-dev mongoose-scenario\n\n\nBasic usage\n-----------\nScenario can be used a variety of ways but the below is the most typical example.\n\n```javascript\nvar mongoose = require('mongoose');\nvar scenario = require('mongoose-scenario')({\n\tconnection: db\n});\n\nscenario({\n\tusers: [\n\t\t{\n\t\t\tname: 'John User',\n\t\t\trole: 'user',\n\t\t\twidgets: ['widget.foo', 'widget.baz'] // These are looked up via the `_ref` property in the widgets collection\n\t\t},\n\t\t{\n\t\t\tname: 'Joe Admin',\n\t\t\trole: 'admin',\n\t\t\twidgets: ['widget.bar']\n\t\t},\n\t],\n\twidgets: [\n\t\t{\n\t\t\t_ref: 'widget.foo',\n\t\t\tname: 'Widget foo',\n\t\t\tcontent: 'This is the foo widget'\n\t\t},\n\t\t{\n\t\t\t_ref: 'widget.bar',\n\t\t\tname: 'Widget bar',\n\t\t\tcontent: 'This is the bar widget'\n\t\t},\n\t\t{\n\t\t\t_ref: 'widget.baz',\n\t\t\tname: 'Widget baz',\n\t\t\tcontent: 'This is the baz widget'\n\t\t},\n\t]\n]);\n```\n\nIn the above a number of users documents are created each refering to an array of widgets. Scenario will create all these records - in the correct order - substituting the 'real' document references as they are created.\n\n\nComparison with Mongo insert()\n------------------------------\nThe 'usual' method to insert records into Mongo is to set the `_id` value of documents to a referencable value in code:\n\n```javascript\n// Setup a user record that has three items which are widgets\n\ndb.widgets.insert({_id: \"widget-foo\", name: \"Widget Foo\"});\ndb.widgets.insert({_id: \"widget-bar\", name: \"Widget Bar\"});\ndb.widgets.insert({_id: \"widget-baz\", name: \"Widget Baz\"});\n\ndb.users.insert({\n\tname: \"John User\",\n\titems: ['widget-foo', 'widget-bar']\n});\n```\n\nHowever this method has the following disadvantages:\n\n1. Its entirely code based - all the inserts must be done in JavaScript rather than a more data friendly format such as JSON\n2. The `_id` fields cannot be auto-generated - this means you can't use the hash format Mongo would normally generate. Instead your fake record IDs would stand out compared to the hash values of 'real' documents.\n\n\n\nOptions\n-------\nOptions are specified when including the module via `require()`:\n\n```javascript\nvar scenario = require('mongoose-scenario')({}, { // NOTE: pass a blank scenario THEN the options\n\t/* Options */\n});\n\nscenario({\n\tcollectionFoo: [],\n\tcollectionBar: []\n}, function(err, data) {\n\tif (err) {\n\t\tconsole.log('Failed to create scenario');\n\t} else {\n\t\tconsole.log('Scenario created', data);\n\t}\n});\n```\n\n\n| Option                              | Type           | Default        | Description                                                            |\n|-------------------------------------|----------------|----------------|------------------------------------------------------------------------|\n| connection                          | _object_       | _none_         | The Mongoose connection object to use                                  |\n| keys                                | _object_       | See code       | The names of the fields Mongoose with reference (see Meta fields section) |\n| nuke                                | _array_        | _none_         | Array of models to clear out (i.e. remove all records) before starting |\n| omitFields                          | _array_        | See code       | Array of fields which should be purged from the row data before its passed to Mongoose |\n| reset                               | _boolean_      | true           | Whether Scenario should disguard references between runs. Set to false to keep previously created row references |\n\n\nExamples\n========\n\nPopulate multiple models\n------------------------\nSimilar to the single model example above, you can also populate multiple models. Either by calling the single model invocation (see above) multiple times or by passing a hash structure to scenario:\n\n\n```javascript\nvar mongoose = require('mongoose');\nvar scenario = require('mongoose-scenario')({\n\tconnection: db\n});\n\nscenario({\n\tusers: [\n\t\t{\n\t\t\tname: 'John User',\n\t\t\trole: 'user'\n\t\t},\n\t\t{\n\t\t\tname: 'Joe Admin',\n\t\t\trole: 'admin'\n\t\t},\n\t],\n\twidgets: [\n\t\t{\n\t\t\tname: 'Widget foo',\n\t\t\tcontent: 'This is the foo widget'\n\t\t},\n\t\t{\n\t\t\tname: 'Widget bar',\n\t\t\tcontent: 'This is the bar widget'\n\t\t},\n\t\t{\n\t\t\tname: 'Widget baz',\n\t\t\tcontent: 'This is the baz widget'\n\t\t},\n\t]\n]);\n```\n\nYou can cross-link objects in the next section.\n\n\n\nCross-model linkages\n--------------------\nDue to the nature of model linkages Scenario provides a simple way to refer to records via the `_ref` property.\nThis property is not actually saved to the Mongo schema. It is used for records to refer to one another during setup.\n\nIn the below example a users and widgets model are created where a user can have multiple widgets allocated in `users.items`.\n\n```javascript\nvar mongoose = require('mongoose');\nvar scenario = require('mongoose-scenario')({\n\tconnection: db\n});\n\nscenario({\n\tusers: [\n\t\t{\n\t\t\tname: 'John User',\n\t\t\trole: 'user',\n\t\t\titems: ['widget-foo']\n\t\t},\n\t\t{\n\t\t\tname: 'Joe Admin',\n\t\t\trole: 'admin',\n\t\t\titems: ['widget-foo', 'widget-baz']\n\t\t},\n\t],\n\twidgets: [\n\t\t{\n\t\t\t_ref: 'widget-foo',\n\t\t\tname: 'Widget foo',\n\t\t\tcontent: 'This is the foo widget'\n\t\t},\n\t\t{\n\t\t\t_ref: 'widget-bar',\n\t\t\tname: 'Widget bar',\n\t\t\tcontent: 'This is the bar widget'\n\t\t},\n\t\t{\n\t\t\t_ref: 'widget-baz',\n\t\t\tname: 'Widget foo',\n\t\t\tcontent: 'This is the baz widget'\n\t\t},\n\t]\n]);\n```\n\nModel specifications and documents can be in any order (i.e. forward or backward-refs are allowed). Scenario will process all records it has and keep pointers to refered records it has not seen yet.\n\nScenario will process any dangling references at the end of each call to its main function so you can call `scenario()` as many times as needed from as many internal stacks as needed and it should do-the-right-thing(tm).\n\n\nUse within tests\n----------------\nScenario can also be used to quickly setup database layouts for tests.\n\nHeres an example using the [Tape](https://github.com/substack/tape) test harness:\n\n```javascript\n\n// Setup our inital options\nvar scenario = require(\"./index.js\")({}, {\n\tconnection: mongoose.connection,\n\tnuke: true\n});\n\ntape('User setup', function(assert) {\n\tassert.plan(1);\n\n\tscenario({\n\t\tusers: [\n\t\t\t{\n\t\t\t\tname: 'Wendy User',\n\t\t\t\trole: 'user',\n\t\t\t\tfavourite: 'widget-quz',\n\t\t\t\titems: ['widget-quz']\n\t\t\t},\n\t\t]\n\t}, function(err, data) {\n\t\tif (err) return assert.fail(err);\n\t\tassert.pass('Scenario setup');\n\t});\n});\n\ntape('User setup - verify', function(assert) {\n\tassert.plan(4);\n\n\tUser\n\t\t.find()\n\t\t.exec(function(err, data) {\n\t\t\tif (err) return assert.fail(err);\n\t\t\tassert.pass('Got user data');\n\t\t\tassert.equal(data.length, 1, 'User row count');\n\t\t\tassert.equal(data[0].name, 'Wendy User');\n\t\t\tassert.equal(data[0].role, 'user');\n\t\t});\n\n});\n```\n\nLook at the [test.js](test.js) file for more detailed examples.\n\n\nMeta field refernce\n===================\nThe following table describes the fields Scenario will example when processing data:\n\n| Field             | Type               | Description                                                            |\n|-------------------|--------------------|------------------------------------------------------------------------|\n| `_ref`            | _string_           | The reference used by other schema definitions (see examples)          |\n| `_after`          | _string_ / _array_ | Indicates that this item should only be created _after_ the referenced items. This is useful if you need rows created in a specific order |\n\n\n\nTODO\n====\n* Setting to use selectors e.g. `widget-foo-*` as multiple glob refs\n* Setting to use `_id` as `_ref`\n* Auto populate data using increment functionality e.g. '{{firstname}} {{lastname}}' fetches some fake first and last names from somewhere\n* Cope with missing dependents (e.g. if record a has missing _ref but record B has it as a dependency)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hash-bang/Node-Mongoose-Scenario/issues"
  },
  "_id": "mongoose-scenario@0.3.4",
  "dist": {
    "shasum": "c681ecae12c928cb38e6b2b5df9fcddcf9f5aa03"
  },
  "_from": "mongoose-scenario@latest",
  "_resolved": "https://registry.npmjs.org/mongoose-scenario/-/mongoose-scenario-0.3.4.tgz"
}
